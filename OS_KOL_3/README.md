# colloc3
Поведенческие шаблоны проектирования
Поведенческие шаблоны проектирования описывают способы организации взаимодействия между объектами. Они способствуют инкапсуляции поведения, разделению ответственности и упрощению модификации бизнес-логики без изменения клиентского кода.

1. Шаблон "Команда" (Command)
Сценарий: Реализация механизма Undo/Redo в текстовом редакторе.
В текстовом редакторе каждое действие пользователя (например, вставка текста или изменение форматирования) инкапсулируется в отдельную команду. Эти команды могут быть сохранены в стеке для последующего выполнения функции отмены (Undo) или повтора (Redo).

Как это работает:

Каждый раз, когда пользователь выполняет действие, создается объект команды, который хранит все данные, необходимые для выполнения и отмены этого действия.

Когда пользователь нажимает "Undo", система извлекает последнюю команду из стека и вызывает её метод отмены, восстанавливая текстовый файл в его предыдущем состоянии.

В случае "Redo" операция выполняется наоборот.

Где применяется:

В текстовых редакторах, таких как Microsoft Word или Notepad++.

В графических редакторах, например, в Photoshop.

В различных приложениях, поддерживающих функции отмены и повтора действий (например, IDE).

2. Шаблон "Стратегия" (Strategy)
Сценарий: Выбор алгоритма сортировки в зависимости от размера массива данных.
В сценарии с сортировкой данные могут быть отсортированы различными алгоритмами, в зависимости от их размера или типа. Например, для малых объемов данных лучше подойдет алгоритм пузырьковой сортировки, а для больших массивов — быстрая сортировка или сортировка слиянием.

Как это работает:

Клиентский код не знает, какой алгоритм используется для сортировки. Он просто передает данные в стратегию сортировки.

В зависимости от размера массива или других факторов, стратегия сортировки может быть выбрана динамически, что позволяет использовать наиболее эффективный алгоритм.

Где применяется:

В библиотеках обработки данных, например, для сортировки списков или массивов в различных приложениях.

В играх, где нужно выбрать разные алгоритмы AI поведения в зависимости от ситуации.

В системах, которые могут обрабатывать различные виды данных с разной сложностью обработки.

3. Шаблон "Шаблонный метод" (Template Method)
Сценарий: Процесс обработки данных из различных источников (CSV, JSON, API).
В процессе извлечения, валидации и сохранения данных из разных источников (например, CSV файл, API или база данных) может использоваться общая структура, а конкретные шаги обработки данных могут отличаться в зависимости от типа источника.

Как это работает:

Основной алгоритм обработки данных всегда одинаков: загрузка данных, их валидация, трансформация и сохранение.

Однако конкретные шаги, такие как загрузка данных (из CSV или API), могут быть реализованы в разных подклассах.

Этот подход позволяет легко расширять и изменять поведение, не меняя основной алгоритм.

Где применяется:

В системах обработки данных (ETL).

В фреймворках тестирования, таких как JUnit, где процесс выполнения тестов всегда один и тот же, но конкретные шаги (например, настройка данных) могут различаться.

В приложениях, которые обрабатывают разные форматы данных (например, веб-скрапинг данных с различных сайтов).

Архитектура и многопоточность
1. Реактивная архитектура (Reactor Pattern)
Сценарий: Веб-сервер, обрабатывающий тысячи одновременных соединений.
В современных веб-приложениях может быть необходимо обрабатывать тысячи одновременных запросов. Для этого применяется реактивная архитектура, которая использует один или несколько потоков для обработки событий, не блокируя их.

Как это работает:

Вся обработка запросов сводится к событиям (например, запрос на получение данных).

Для каждого события не блокируется поток, а создаются асинхронные обработчики, которые позволяют одному потоку обрабатывать множество запросов.

Это повышает производительность и масштабируемость системы, так как поток не тратится на ожидание завершения операции, а может продолжать обработку других событий.

Где применяется:

В высоконагруженных веб-серверах, например, в Node.js или Netty, которые обрабатывают множество одновременных запросов.

В асинхронных фреймворках, таких как Spring WebFlux, которые используются для реализации реактивных приложений.

В реальном времени обработка событий (например, в системах мониторинга или трейдинговых приложениях).

2. Микросервисная архитектура с использованием очередей сообщений (например, Kafka)
Сценарий: Система заказов в интернет-магазине.
Интернет-магазин имеет несколько сервисов, таких как сервис для оформления заказов, сервис для оплаты и сервис для уведомлений. Каждый из этих сервисов должен работать независимо и обмениваться сообщениями.

Как это работает:

Когда пользователь оформляет заказ, запрос поступает в очередь сообщений (например, Kafka или RabbitMQ).

Каждый сервис (заказы, оплата, уведомления) читает сообщения из очереди и выполняет свою задачу, не блокируя другие сервисы.

Система становится масштабируемой, так как можно добавлять новые экземпляры сервисов или изменять поведение сервисов, не нарушая общую логику приложения.

Где применяется:

В микросервисных архитектурах, где каждый компонент системы может быть отдельным сервисом, отвечающим за выполнение своей задачи (например, в Netflix, Amazon).

В системах обработки данных, которые требуют асинхронного взаимодействия между компонентами (например, обработка и анализ больших объёмов данных).

В архитектуре событий, где данные передаются по очередям между различными компонентами системы, например, в IoT приложениях.

Влияние многопоточности на архитектуру
Сценарий: Реализация многозадачности в приложении с разделением работы между потоками.
Когда приложение должно обрабатывать множество параллельных запросов или выполнять длительные операции в фоновом режиме (например, скачивание файлов, обработка видео или обработка данных), многопоточность позволяет эффективно разделить работу между несколькими потоками.

Как это работает:

Каждый поток выполняет свою задачу независимо от других.

Используется пул потоков, который управляет количеством активных потоков и распределяет задачи по доступным потокам.

Это значительно повышает производительность и снижает время отклика системы.

Где применяется:

В системах, требующих высокой производительности и отклика, таких как веб-сервисы, игровые серверы или системы анализа данных в реальном времени.

В фоновом вычислении, где задача делится на несколько частей, которые могут быть выполнены параллельно, например, в научных вычислениях или обработке больших данных.

В многозадачных приложениях, таких как многозадачные операционные системы, браузеры и мобильные приложения.
